# Introduction to SQLAlchemy Core and Python

QLAlchemy Core allows you to interact with `relational databases` using statements written in pure Python. This allows you to form queries and use your database without that much knowledge of SQL.

Let's see how to connect to an SQL database as well as to Create, Read, Update, and Delete records from your database.

## ðŸ”¹Create a virtual environment in Python.

- [x] run: `python -m venv env`

`venv` is a built-in module in Python that allows you to create isolated Python environments. The env in python -m venv env is the name of the directory where the virtual environment will be created. You can choose any name for this directory.

Once the virtual environment is created, you can activate it using the appropriate command based on your operating system.

- on Windows: `.\env\Scripts\activate`
- on Unix or Linux: `source env/bin/activate`

(You will see `(env)` before the paths in the terminal now)

ðŸ‘‰ Activating the virtual environment allows you to install and manage Python packages separately from your system's Python installation, ensuring that the dependencies for your project are isolated and won't conflict with other projects.

## ðŸ”¹Install SQLAlchemy

- [x] run: `pip install sqlalchemy`

Revise the version:

- Create a file called "connect.py" and write:

```
import sqlalchemy
print(sqlalchemy.__version__)

```

And then, either run the triangle on the rigth top of the file, or run this in the terminal: `python connect.py`

(version when this repository was being made: 2.0.21)

## ðŸ”¹Connecting to the database

```
from sqlalchemy import create_engine

engine = create_engine('sqlite:///', echo=True)
```

- `create_engine()` is a function provided by SQLAlchemy that creates a new database engine object. This engine acts as a gateway to connect and interact with a database.

- `'sqlite:///` is the connection string passed as an argument to create_engine() . It specifies the database dialect (SQLite in this case) and the location of the database file.

SQLite is a lightweight relational database management system (RDBMS)

The `sqlite3` module, which allows Python to interact with SQLite databases, is included in the standard library of Python. This means that when you install Python, you automatically have access to the sqlite3 module without needing to install any additional packages.

The triple forward slash `///` is a convention used to specify the relative path to a SQLite database file. It indicates that `the database file is located in the current working directory`.

`sqlite:///sample.db` specifies a specific SQLite database file named "sample.db". The database file "sample.db" will be created within the same directory where the Python script is being executed or where the script's working directory is set.

If you wanted to specify an absolute path to the database file, you would use four forward slashes ( //// ) instead of three, similar to the previous explanation. For example, 'sqlite:////path/to/sample.db' .

- `echo=True` is an optional parameter that enables logging of all SQL statements generated by SQLAlchemy. When set to True , it will `print the SQL statements to the console`, which can be `helpful` for debugging and understanding the database interactions.

So, when this code is executed, it creates a SQLite database engine object named engine that connects to an in-memory SQLite database. The echo=True parameter enables logging of SQL statements.

This engine can then be used to establish connections, execute queries, and perform other database operations using SQLAlchemy's API.

## ðŸ”¹Testing database

Try running this in your connect.py file:

```
with engine.connect() as conn:
    result = conn.execute(text('SELECT "Hello"'))

    print(result.all())

```

You should see sqlalchemy working:

```
2023-09-28 11:48:27,485 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2023-09-28 11:48:27,485 INFO sqlalchemy.engine.Engine SELECT "Hello"
2023-09-28 11:48:27,485 INFO sqlalchemy.engine.Engine [generated in 0.00151s] ()
[('Hello',)]
2023-09-28 11:48:27,487 INFO sqlalchemy.engine.Engine ROLLBACK
```

You'll also see a new file created: `sample.db`

## ðŸ”¹Define database tables

In another file called `tables.py`:

- Import the necessary classes from the SQLAlchemy library to define tables, metadata, and columns:

(example: )`from sqlalchemy import Table, MetaData, Column `

- Import specific data types needed for column definitions:

(example: )`from sqlalchemy import Integer, String, Text, ForeignKey`

- `meta_obj = MetaData()` creates a new instance of the MetaData class. MetaData is used to hold all the database schema information.

- Example of tables:

```
users_table = Table(
  "users",
  meta_obj,
  Column("id", Integer, primary_key=True),
  Column("name", String(50), nullable=False),
  Column("fullname", Text),

)

comments_table = Table(
  "comments",
  meta_obj,
  Column("id", Integer, primary_key=True),
  Column("comment", Text, nullable=False),
  Column("user_id", Integer, ForeignKey("users.id")),
)
```

The `nullable=False` argument specifies that the column cannot be empty.

## ðŸ”¹Metadata Object:

It is a container that holds all the information about a database schema. It acts as a `central repository for storing metadata related to tables, columns, constraints, and other database objects`.

1. Purpose: The MetaData object is used to define and manage the structure of a database schema. It allows you to define tables, columns, constraints, and other database objects using SQLAlchemy's expressive syntax.

2. Relationship with Tables: The MetaData object is associated with one or more Table objects. You can add tables to the metadata object using the Table constructor, as shown in your code example.

3. Reflection: The MetaData object also provides a useful feature called "reflection." Reflection allows SQLAlchemy to automatically load the structure of an existing database into the MetaData object. This means you can generate Table objects based on an existing database schema without explicitly defining them in code.

4. Database Independence: The MetaData object facilitates database independence. It abstracts away the differences between various database engines, allowing you to write code that can work with different database systems seamlessly.

5. Relationship with Engine: The MetaData object is often associated with a database engine. When you bind the MetaData object to an engine, it allows SQLAlchemy to establish a connection to the database and perform operations like table creation, schema updates, and data manipulation.

6. Data Migration: The MetaData object plays a crucial role in database migrations. It allows you to track and manage changes to the database schema over time, making it easier to evolve the structure of your database as your application evolves.

Overall, the MetaData object in SQLAlchemy provides a powerful and flexible way to define, manage, and work with the structure of a database schema in Python. It simplifies the process of interacting with databases and enables you to write database-agnostic code.

## ðŸ”¹Create tables in the database:

So, we create our database file: `create_db.py`

We import the engine and the tables:

```
from connect import engine
from tables import meta_obj, users_table, comments_table
```

Then let's create the database:

```
print(">>>CREATE DATABASE")
meta_obj.create_all(bind=engine)
```

- The code snippet print(">>>CREATE DATABASE") is a simple print statement that outputs the string ">>>CREATE DATABASE" to the console. It is commonly used to provide information or debugging messages during program execution.

- The second line, meta_obj.create_all(bind=engine), is likely using SQLAlchemy to create database tables based on the defined metadata object (meta_obj) and bind them to the specified database engine (engine).

The `create_all()` method in SQLAlchemy is used to automatically create all the tables defined in the metadata object. By calling this method with the `bind parameter` set to the database engine, SQLAlchemy will execute the necessary SQL statements to create the tables in the connected database.

This code is typically used when setting up a new database or when you want to ensure that all the required tables are present in the database before performing any operations that depend on them.

Run the file and see in the console the process:

```
2023-09-28 13:33:47,444 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2023-09-28 13:33:47,445 INFO sqlalchemy.engine.Engine SELECT "Hello"
2023-09-28 13:33:47,445 INFO sqlalchemy.engine.Engine [generated in 0.00047s] ()
[('Hello',)]
2023-09-28 13:33:47,445 INFO sqlalchemy.engine.Engine ROLLBACK
>>>CREATE DATABASE
2023-09-28 13:33:47,450 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2023-09-28 13:33:47,451 INFO sqlalchemy.engine.Engine PRAGMA main.table_info("users")2023-09-28 13:33:47,451 INFO sqlalchemy.engine.Engine [raw sql] ()
2023-09-28 13:33:47,451 INFO sqlalchemy.engine.Engine PRAGMA temp.table_info("users")2023-09-28 13:33:47,451 INFO sqlalchemy.engine.Engine [raw sql] ()
2023-09-28 13:33:47,452 INFO sqlalchemy.engine.Engine PRAGMA main.table_info("comments")
2023-09-28 13:33:47,452 INFO sqlalchemy.engine.Engine [raw sql] ()
2023-09-28 13:33:47,453 INFO sqlalchemy.engine.Engine PRAGMA temp.table_info("comments")
2023-09-28 13:33:47,453 INFO sqlalchemy.engine.Engine [raw sql] ()
2023-09-28 13:33:47,453 INFO sqlalchemy.engine.Engine
CREATE TABLE users (
        id INTEGER NOT NULL,
        name VARCHAR(50) NOT NULL,
        fullname TEXT,
        PRIMARY KEY (id)
)


2023-09-28 13:33:47,454 INFO sqlalchemy.engine.Engine [no key 0.00064s] ()
2023-09-28 13:33:47,466 INFO sqlalchemy.engine.Engine
CREATE TABLE comments (
        id INTEGER NOT NULL,
        comment TEXT NOT NULL,
        user_id INTEGER,
        PRIMARY KEY (id),
        FOREIGN KEY(user_id) REFERENCES users (id)
)


2023-09-28 13:33:47,467 INFO sqlalchemy.engine.Engine [no key 0.00095s] ()
2023-09-28 13:33:47,470 INFO sqlalchemy.engine.Engine COMMIT
```

## DB BROWSER

We can see our database created in a program called [DB Browser](https://sqlitebrowser.org/)

[Install it](https://sqlitebrowser.org/dl/) and open the `sample.db` file in the program.

You'll see there the tables and the columns of each.

## INSERT STATEMENTS

Create a new file called `inserting.py` and import the `insert` function and the table you want to modify:

```
from sqlalchemy import insert
from tables import users_table

```

You don't know what values to insert? don't worry, python helps:

(example) run this:

```
statement = insert(users_table)

print(statement)
```

In the console you'll see the values to be introduced.

```
INSERT INTO users (id, name, fullname) VALUES (:id, :name, :fullname)
```

So, to introduce them, we'll import the engine:

```
from connect import engine
```

Insert them and establish a connection to the database to create them and save them:

```
statement = insert(users_table).values(name="Vanesa", fullname="Juarez")

with engine.connect() as conn:
    conn.execute(statement)
    conn.commit()

```

`with engine.connect() as conn:`: This line establishes a connection to the database engine specified by the engine object. The `with` statement ensures that the connection is automatically closed after the block of code is executed.

`conn.execute(statement)`: This line executes the INSERT statement against the database by calling the execute() method on the connection object `conn` and passing the statement as the argument.

`conn.commit()`: This line commits the transaction, saving the changes made by the INSERT operation to the database.

Run the file and see:

```
2023-09-28 14:16:35,999 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2023-09-28 14:16:35,999 INFO sqlalchemy.engine.Engine INSERT INTO users (name, fullname) VALUES (?, ?)
2023-09-28 14:16:36,000 INFO sqlalchemy.engine.Engine [generated in 0.00078s] ('Vanesa', 'Juarez')
2023-09-28 14:16:36,002 INFO sqlalchemy.engine.Engine COMMIT
```

You'll also find the values immediately in the DB Browser program.

Let's create more users:

```
with engine.connect() as conn:
    conn.execute(statement, [
        {'name': 'Walter', 'fullname': 'White'},
        {'name': 'Lizz', 'fullname': 'Ginger'},
    ])
    conn.commit()
```

```
2023-09-28 14:23:54,784 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2023-09-28 14:23:54,785 INFO sqlalchemy.engine.Engine INSERT INTO users (name, fullname) VALUES (?, ?)
2023-09-28 14:23:54,786 INFO sqlalchemy.engine.Engine [generated in 0.00152s] [('Walter', 'White'), ('Lizz', 'Ginger')]
2023-09-28 14:23:54,795 INFO sqlalchemy.engine.Engine COMMIT
```

## Retrieve Data/ Select Statements

Create the file `selecting.py` and import what we need:

```
from sqlalchemy import select
from tables import users_table
from connect import engine
```

See your table structure in the console. Run this in the file:

```
statement = select(users_table)

print(statement)
```

See this in the console:

```
SELECT users.id, users.name, users.fullname
FROM users
```

If you want to see the actual data, you have to connect to the database:

```
statement = select(users_table)

with engine.connect() as conn:
    result = conn.execute(statement)
    for row in result:
        print(row)
```

And you see this in the console:

```
2023-09-28 14:34:54,445 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2023-09-28 14:34:54,446 INFO sqlalchemy.engine.Engine SELECT users.id, users.name, users.fullname
FROM users
2023-09-28 14:34:54,446 INFO sqlalchemy.engine.Engine [generated in 0.00072s] ()
(1, 'Vanesa', 'Juarez')
(2, 'Walter', 'White')
(3, 'Lizz', 'Ginger')

```

Another way of printing. Run this:

```
with engine.connect() as conn:
    result = conn.execute(statement)

    for row in result:
        print(f"<Username: {row.name}, Fullname: {row.fullname}>")
```

And in the console you see this:

```
2023-09-28 14:38:41,239 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2023-09-28 14:38:41,240 INFO sqlalchemy.engine.Engine SELECT users.id, users.name, users.fullname
FROM users
2023-09-28 14:38:41,240 INFO sqlalchemy.engine.Engine [generated in 0.00090s] ()
<Username: Vanesa, Fullname: Juarez>
<Username: Walter, Fullname: White>
<Username: Lizz, Fullname: Ginger>
2023-09-28 14:38:41,242 INFO sqlalchemy.engine.Engine ROLLBACK
```

The `f`-string is used to dynamically insert the values of row.name and row.fullname into the string. The curly braces `{}` are used to enclose the expressions that will be evaluated and replaced with their corresponding values.

## Selecting with conditions:

To add a condition to the search, we have to use the .where clause next to the selection:

```
statement = select(users_table).where(users_table.c.name == 'Walter')


with engine.connect() as conn:
    result = conn.execute(statement)

    for row in result:
        print(row)
```

`c` is an attribute of the table object that represents the column of the table.

## Update data

Create a new file `updating.py` and import all as always (and the function `update`).

If you want to see what you're statement is going to do, print it first:

```
statement = update(users_table).where(users_table.c.name == 'Walter').values(name='Chusta')

print(statement)
```

You'll see so in the console:

```
UPDATE users SET name=:name WHERE users.name = :name_1
```

Now run it with the connection:

```
statement = update(users_table).where(users_table.c.name == 'Walter').values(name='Chusta')

with engine.connect() as conn:
    result = conn.execute(statement)
    conn.commit()
```

And in the console you'll see you changed the value:

```
2023-09-28 14:55:48,410 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2023-09-28 14:55:48,411 INFO sqlalchemy.engine.Engine UPDATE users SET name=? WHERE users.name = ?
2023-09-28 14:55:48,411 INFO sqlalchemy.engine.Engine [generated in 0.00091s] ('Chusta', 'Walter')
2023-09-28 14:55:48,420 INFO sqlalchemy.engine.Engine COMMIT
```

## Delete data

So let's go ahead an create a file for this too, so it's all organized: `deleting.py`. And the same:

```
from sqlalchemy import delete
from tables import users_table
from connect import engine

statement = delete(users_table).where(users_table.c.name == 'Chusta')

with engine.connect() as conn:
    result = conn.execute(statement)
    conn.commit()
```

```
2023-09-28 15:01:40,650 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2023-09-28 15:01:40,651 INFO sqlalchemy.engine.Engine DELETE FROM users WHERE users.name = ?
2023-09-28 15:01:40,651 INFO sqlalchemy.engine.Engine [generated in 0.00096s] ('Chusta',)
2023-09-28 15:01:40,660 INFO sqlalchemy.engine.Engine COMMIT
```
