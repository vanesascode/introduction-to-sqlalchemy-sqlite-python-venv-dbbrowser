# Introduction to SQLAlchemy Core and Python

SQLAlchemy is a Python library that provides a set of tools for interacting with databases. It offers two main components: the SQLAlchemy Core and the SQLAlchemy ORM.

ðŸ”¸ SQLAlchemy `Core` is a lower-level interface that allows you to work with `SQL directly`.

ðŸ”¸ SQLAlchemy `ORM` is a higher-level interface that allows you to work with databases using `Python objects`.

The choice between the two depends on your specific requirements and preferences.

## ðŸ”¹Create a virtual environment in Python.

- [x] run: `python -m venv env`

`venv` is a built-in module in Python that allows you to create isolated Python environments. The env in python -m venv env is the name of the directory where the virtual environment will be created. You can choose any name for this directory.

Once the virtual environment is created, you can activate it using the appropriate command based on your operating system.

- on Windows: `.\env\Scripts\activate`
- on Unix or Linux: `source env/bin/activate`

(You will see `(env)` before the paths in the terminal now)

ðŸ‘‰ Activating the virtual environment allows you to install and manage Python packages separately from your system's Python installation, ensuring that the dependencies for your project are isolated and won't conflict with other projects.

### Option of a virtual environment + package manager:

The commands python `-m venv env` and `pipenv install --python 3` are used for creating virtual environments in Python, but they use different tools and have different purposes.

- python -m venv env: This command is used to create a virtual environment using the built-in venv module in Python. It creates a new directory named env (you can choose a different name) and sets up a virtual environment within that directory. The virtual environment isolates the Python environment and allows you to install packages and dependencies specific to your project without interfering with the global Python installation.

To activate the virtual environment, you would typically run the appropriate command for your operating system. For example, in Windows, you would run `env\Scripts\activate`, and in Unix/Linux, you would run `source env/bin/activate`. Once activated, any subsequent Python and pip commands will use the Python interpreter and packages installed within the virtual environment.

- pipenv install --python 3: This command is used with the pipenv tool, which is a higher-level package manager for Python projects. It combines the functionality of pip and virtualenv into a single tool. The install command is used to create a virtual environment and install project dependencies within that environment.
  The --python 3 option tells pipenv to create the virtual environment using Python 3. If you don't specify the Python version, pipenv will use the system's default Python interpreter.

When you run pipenv install --python 3, it creates a new virtual environment and `installs the packages listed in the Pipfile (if it exists) or the requirements.txt file (if it exists)` into that environment. It also generates a `Pipfile.lock` file to lock the versions of the installed packages.

To activate the virtual environment created by pipenv, you would typically run `pipenv shell` command, which spawns a new shell with the virtual environment activated. Within the shell, any subsequent Python and pip commands will use the Python interpreter and packages installed within the virtual environment.

In summary, python -m venv env is a command to create a virtual environment using the built-in venv module, while pipenv install --python 3 is a command to create a virtual environment and manage packages using the pipenv tool. The choice between these commands depends on your specific needs and preferences.

### Pipfile

A Pipfile is a configuration file used by the pipenv tool, which is a higher-level package manager for Python projects. It is designed to simplify and streamline the management of project dependencies and virtual environments.

The Pipfile is typically located in the root directory of a Python project and contains information about the project's dependencies, including the name of each package and its corresponding version constraint. It is written in a human-readable format that resembles a Python dictionary.

ðŸ‘‰ Note that the Pipfile is used by the pipenv tool, and it is not directly used by other package managers like pip. If you are not using pipenv, you may use a different file, such as `requirements.txt`, to specify project dependencies for other package managers.

### Pipfile.lock

The Pipfile.lock file is generated by the pipenv tool when you run `pipenv install` or `pipenv update` commands. It serves as a lock file that records the specific versions of packages that were installed in the virtual environment based on the Pipfile.

The Pipfile.lock file ensures that the same versions of packages are installed consistently across different environments, making it easier to reproduce the exact environment for your Python project.

To ensure a clean and consistent project setup, it is recommended to follow these guidelines:

- `Include Pipfile.lock in version control`: Commit the Pipfile.lock file to your version control system (e.g., Git) along with other project files. This allows other developers or deployment environments to easily recreate the same environment.

- `Exclude virtual environment directories`: While the Pipfile.lock file should be included, it is generally advisable to exclude the actual virtual environment directories (env or venv) from version control. These directories can be large and contain files that can be generated from the Pipfile.lock file. Instead, developers or deployment environments can recreate the virtual environment using the Pipfile.lock file.

## ðŸ”¹Install SQLAlchemy

- [x] run: `pip install sqlalchemy`

Revise the version:

- Create a file called "connect.py" and write:

```
import sqlalchemy
print(sqlalchemy.__version__)

```

And then, either run the triangle on the rigth top of the file, or run this in the terminal: `python connect.py`

(version when this repository was being made: 2.0.21)

## ðŸ”¹Connecting to the database

```
from sqlalchemy import create_engine

engine = create_engine('sqlite:///', echo=True)
```

- `create_engine()` is a function provided by SQLAlchemy that creates a new database engine object. This engine acts as a gateway to connect and interact with a database.

- `'sqlite:///` is the connection string passed as an argument to create_engine() . It specifies the database dialect (SQLite in this case) and the location of the database file.

SQLite is a lightweight relational database management system (RDBMS)

The `sqlite3` module, which allows Python to interact with SQLite databases, is included in the standard library of Python. This means that when you install Python, you automatically have access to the sqlite3 module without needing to install any additional packages.

The triple forward slash `///` is a convention used to specify the relative path to a SQLite database file. It indicates that `the database file is located in the current working directory`.

`sqlite:///sample.db` specifies a specific SQLite database file named "sample.db". The database file "sample.db" will be created within the same directory where the Python script is being executed or where the script's working directory is set.

If you wanted to specify an absolute path to the database file, you would use four forward slashes ( //// ) instead of three, similar to the previous explanation. For example, 'sqlite:////path/to/sample.db' .

- `echo=True` is an optional parameter that enables logging of all SQL statements generated by SQLAlchemy. When set to True , it will `print the SQL statements to the console`, which can be `helpful` for debugging and understanding the database interactions.

So, when this code is executed, it creates a SQLite database engine object named engine that connects to an in-memory SQLite database. The echo=True parameter enables logging of SQL statements.

This engine can then be used to establish connections, execute queries, and perform other database operations using SQLAlchemy's API.

## ðŸ”¹Testing database

Try running this in your connect.py file:

```
with engine.connect() as conn:
    result = conn.execute(text('SELECT "Hello"'))

    print(result.all())

```

You should see sqlalchemy working:

```
2023-09-28 11:48:27,485 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2023-09-28 11:48:27,485 INFO sqlalchemy.engine.Engine SELECT "Hello"
2023-09-28 11:48:27,485 INFO sqlalchemy.engine.Engine [generated in 0.00151s] ()
[('Hello',)]
2023-09-28 11:48:27,487 INFO sqlalchemy.engine.Engine ROLLBACK
```

You'll also see a new file created: `sample.db`

# ðŸŒŸSQLAlchemy COREðŸŒŸ

The SQLAlchemy Core is a lower-level interface that allows you to interact with databases using `SQL expressions` directly. It provides a set of classes and functions that represent database tables, columns, and other SQL constructs.

With the Core, you have more control over the SQL statements being executed and can write complex queries directly.

## ðŸ”¹Define database tables

In another file called `tables.py`:

- Import the necessary classes from the SQLAlchemy library to define tables, metadata, and columns:

(example: )`from sqlalchemy import Table, MetaData, Column `

- Import specific data types needed for column definitions:

(example: )`from sqlalchemy import Integer, String, Text, ForeignKey`

- `meta_obj = MetaData()` creates a new instance of the MetaData class. MetaData is used to hold all the database schema information.

- Example of tables:

```
users_table = Table(
  "users",
  meta_obj,
  Column("id", Integer, primary_key=True),
  Column("name", String(50), nullable=False),
  Column("fullname", Text),

)

comments_table = Table(
  "comments",
  meta_obj,
  Column("id", Integer, primary_key=True),
  Column("comment", Text, nullable=False),
  Column("user_id", Integer, ForeignKey("users.id")),
)
```

The `nullable=False` argument specifies that the column cannot be empty.

## ðŸ”¹Metadata Object:

It is a container that holds all the information about a database schema. It acts as a `central repository for storing metadata related to tables, columns, constraints, and other database objects`.

1. Purpose: The MetaData object is used to define and manage the structure of a database schema. It allows you to define tables, columns, constraints, and other database objects using SQLAlchemy's expressive syntax.

2. Relationship with Tables: The MetaData object is associated with one or more Table objects. You can add tables to the metadata object using the Table constructor, as shown in your code example.

3. Reflection: The MetaData object also provides a useful feature called "reflection." Reflection allows SQLAlchemy to automatically load the structure of an existing database into the MetaData object. This means you can generate Table objects based on an existing database schema without explicitly defining them in code.

4. Database Independence: The MetaData object facilitates database independence. It abstracts away the differences between various database engines, allowing you to write code that can work with different database systems seamlessly.

5. Relationship with Engine: The MetaData object is often associated with a database engine. When you bind the MetaData object to an engine, it allows SQLAlchemy to establish a connection to the database and perform operations like table creation, schema updates, and data manipulation.

6. Data Migration: The MetaData object plays a crucial role in database migrations. It allows you to track and manage changes to the database schema over time, making it easier to evolve the structure of your database as your application evolves.

Overall, the MetaData object in SQLAlchemy provides a powerful and flexible way to define, manage, and work with the structure of a database schema in Python. It simplifies the process of interacting with databases and enables you to write database-agnostic code.

## ðŸ”¹Create tables in the database:

So, we create our database file: `create_db.py`

We import the engine and the tables:

```
from connect import engine
from tables import meta_obj, users_table, comments_table
```

Then let's create the database:

```
print(">>>CREATE DATABASE")
meta_obj.create_all(bind=engine)
```

- The code snippet print(">>>CREATE DATABASE") is a simple print statement that outputs the string ">>>CREATE DATABASE" to the console. It is commonly used to provide information or debugging messages during program execution.

- The second line, meta_obj.create_all(bind=engine), is likely using SQLAlchemy to create database tables based on the defined metadata object (meta_obj) and bind them to the specified database engine (engine).

The `create_all()` method in SQLAlchemy is used to automatically create all the tables defined in the metadata object. By calling this method with the `bind parameter` set to the database engine, SQLAlchemy will execute the necessary SQL statements to create the tables in the connected database.

This code is typically used when setting up a new database or when you want to ensure that all the required tables are present in the database before performing any operations that depend on them.

Run the file and see in the console the process:

```
2023-09-28 13:33:47,444 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2023-09-28 13:33:47,445 INFO sqlalchemy.engine.Engine SELECT "Hello"
2023-09-28 13:33:47,445 INFO sqlalchemy.engine.Engine [generated in 0.00047s] ()
[('Hello',)]
2023-09-28 13:33:47,445 INFO sqlalchemy.engine.Engine ROLLBACK
>>>CREATE DATABASE
2023-09-28 13:33:47,450 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2023-09-28 13:33:47,451 INFO sqlalchemy.engine.Engine PRAGMA main.table_info("users")2023-09-28 13:33:47,451 INFO sqlalchemy.engine.Engine [raw sql] ()
2023-09-28 13:33:47,451 INFO sqlalchemy.engine.Engine PRAGMA temp.table_info("users")2023-09-28 13:33:47,451 INFO sqlalchemy.engine.Engine [raw sql] ()
2023-09-28 13:33:47,452 INFO sqlalchemy.engine.Engine PRAGMA main.table_info("comments")
2023-09-28 13:33:47,452 INFO sqlalchemy.engine.Engine [raw sql] ()
2023-09-28 13:33:47,453 INFO sqlalchemy.engine.Engine PRAGMA temp.table_info("comments")
2023-09-28 13:33:47,453 INFO sqlalchemy.engine.Engine [raw sql] ()
2023-09-28 13:33:47,453 INFO sqlalchemy.engine.Engine
CREATE TABLE users (
        id INTEGER NOT NULL,
        name VARCHAR(50) NOT NULL,
        fullname TEXT,
        PRIMARY KEY (id)
)


2023-09-28 13:33:47,454 INFO sqlalchemy.engine.Engine [no key 0.00064s] ()
2023-09-28 13:33:47,466 INFO sqlalchemy.engine.Engine
CREATE TABLE comments (
        id INTEGER NOT NULL,
        comment TEXT NOT NULL,
        user_id INTEGER,
        PRIMARY KEY (id),
        FOREIGN KEY(user_id) REFERENCES users (id)
)


2023-09-28 13:33:47,467 INFO sqlalchemy.engine.Engine [no key 0.00095s] ()
2023-09-28 13:33:47,470 INFO sqlalchemy.engine.Engine COMMIT
```

## ðŸ”¹DB BROWSER

We can see our database created in a program called [DB Browser](https://sqlitebrowser.org/)

[Install it](https://sqlitebrowser.org/dl/) and open the `sample.db` file in the program.

You'll see there the tables and the columns of each.

## ðŸ”¹Insert Statements

Create a new file called `inserting.py` and import the `insert` function and the table you want to modify:

```
from sqlalchemy import insert
from tables import users_table

```

You don't know what values to insert? don't worry, python helps:

(example) run this:

```
statement = insert(users_table)

print(statement)
```

In the console you'll see the values to be introduced.

```
INSERT INTO users (id, name, fullname) VALUES (:id, :name, :fullname)
```

So, to introduce them, we'll import the engine:

```
from connect import engine
```

Insert them and establish a connection to the database to create them and save them:

```
statement = insert(users_table).values(name="Vanesa", fullname="Juarez")

with engine.connect() as conn:
    conn.execute(statement)
    conn.commit()

```

`with engine.connect() as conn:`: This line establishes a connection to the database engine specified by the engine object. The `with` statement ensures that the connection is automatically closed after the block of code is executed.

`conn.execute(statement)`: This line executes the INSERT statement against the database by calling the execute() method on the connection object `conn` and passing the statement as the argument.

`conn.commit()`: This line commits the transaction, saving the changes made by the INSERT operation to the database.

Run the file and see:

```
2023-09-28 14:16:35,999 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2023-09-28 14:16:35,999 INFO sqlalchemy.engine.Engine INSERT INTO users (name, fullname) VALUES (?, ?)
2023-09-28 14:16:36,000 INFO sqlalchemy.engine.Engine [generated in 0.00078s] ('Vanesa', 'Juarez')
2023-09-28 14:16:36,002 INFO sqlalchemy.engine.Engine COMMIT
```

You'll also find the values immediately in the DB Browser program.

Let's create more users:

```
with engine.connect() as conn:
    conn.execute(statement, [
        {'name': 'Walter', 'fullname': 'White'},
        {'name': 'Lizz', 'fullname': 'Ginger'},
    ])
    conn.commit()
```

```
2023-09-28 14:23:54,784 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2023-09-28 14:23:54,785 INFO sqlalchemy.engine.Engine INSERT INTO users (name, fullname) VALUES (?, ?)
2023-09-28 14:23:54,786 INFO sqlalchemy.engine.Engine [generated in 0.00152s] [('Walter', 'White'), ('Lizz', 'Ginger')]
2023-09-28 14:23:54,795 INFO sqlalchemy.engine.Engine COMMIT
```

## ðŸ”¹Retrieve Data/ Select Statements

Create the file `selecting.py` and import what we need:

```
from sqlalchemy import select
from tables import users_table
from connect import engine
```

See your table structure in the console. Run this in the file:

```
statement = select(users_table)

print(statement)
```

See this in the console:

```
SELECT users.id, users.name, users.fullname
FROM users
```

If you want to see the actual data, you have to connect to the database:

```
statement = select(users_table)

with engine.connect() as conn:
    result = conn.execute(statement)
    for row in result:
        print(row)
```

And you see this in the console:

```
2023-09-28 14:34:54,445 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2023-09-28 14:34:54,446 INFO sqlalchemy.engine.Engine SELECT users.id, users.name, users.fullname
FROM users
2023-09-28 14:34:54,446 INFO sqlalchemy.engine.Engine [generated in 0.00072s] ()
(1, 'Vanesa', 'Juarez')
(2, 'Walter', 'White')
(3, 'Lizz', 'Ginger')

```

Another way of printing. Run this:

```
with engine.connect() as conn:
    result = conn.execute(statement)

    for row in result:
        print(f"<Username: {row.name}, Fullname: {row.fullname}>")
```

And in the console you see this:

```
2023-09-28 14:38:41,239 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2023-09-28 14:38:41,240 INFO sqlalchemy.engine.Engine SELECT users.id, users.name, users.fullname
FROM users
2023-09-28 14:38:41,240 INFO sqlalchemy.engine.Engine [generated in 0.00090s] ()
<Username: Vanesa, Fullname: Juarez>
<Username: Walter, Fullname: White>
<Username: Lizz, Fullname: Ginger>
2023-09-28 14:38:41,242 INFO sqlalchemy.engine.Engine ROLLBACK
```

The `f`-string is used to dynamically insert the values of row.name and row.fullname into the string. The curly braces `{}` are used to enclose the expressions that will be evaluated and replaced with their corresponding values.

## ðŸ”¹Selecting with conditions:

To add a condition to the search, we have to use the .where clause next to the selection:

```
statement = select(users_table).where(users_table.c.name == 'Walter')


with engine.connect() as conn:
    result = conn.execute(statement)

    for row in result:
        print(row)
```

`c` is an attribute of the table object that represents the column of the table.

## ðŸ”¹Update data

Create a new file `updating.py` and import all as always (and the function `update`).

If you want to see what you're statement is going to do, print it first:

```
statement = update(users_table).where(users_table.c.name == 'Walter').values(name='Chusta')

print(statement)
```

You'll see so in the console:

```
UPDATE users SET name=:name WHERE users.name = :name_1
```

Now run it with the connection:

```
statement = update(users_table).where(users_table.c.name == 'Walter').values(name='Chusta')

with engine.connect() as conn:
    result = conn.execute(statement)
    conn.commit()
```

And in the console you'll see you changed the value:

```
2023-09-28 14:55:48,410 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2023-09-28 14:55:48,411 INFO sqlalchemy.engine.Engine UPDATE users SET name=? WHERE users.name = ?
2023-09-28 14:55:48,411 INFO sqlalchemy.engine.Engine [generated in 0.00091s] ('Chusta', 'Walter')
2023-09-28 14:55:48,420 INFO sqlalchemy.engine.Engine COMMIT
```

## ðŸ”¹Delete data

So let's go ahead an create a file for this too, so it's all organized: `deleting.py`. And the same:

```
from sqlalchemy import delete
from tables import users_table
from connect import engine

statement = delete(users_table).where(users_table.c.name == 'Chusta')

with engine.connect() as conn:
    result = conn.execute(statement)
    conn.commit()
```

```
2023-09-28 15:01:40,650 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2023-09-28 15:01:40,651 INFO sqlalchemy.engine.Engine DELETE FROM users WHERE users.name = ?
2023-09-28 15:01:40,651 INFO sqlalchemy.engine.Engine [generated in 0.00096s] ('Chusta',)
2023-09-28 15:01:40,660 INFO sqlalchemy.engine.Engine COMMIT
```

# ðŸŒŸSQLAlchemy ORMðŸŒŸ

The SQLAlchemy ORM (Object-Relational Mapping) is a higher-level interface that allows you to interact with databases using Python objects.

It provides a way to define classes that represent database tables and relationships between them.

The ORM handles the translation between Python objects and database records, allowing you to work with databases `using object-oriented programming techniques`.

## ðŸ”¹Database Models:

Database models are `representations` of database tables and the relationships between them. In the context of SQLAlchemy, database models are typically defined `using the SQLAlchemy ORM` (Object-Relational Mapping).

A database model is typically represented as a Python class that inherits from a `base class` provided by SQLAlchemy. Each attribute of the class represents a column in the corresponding database table, and the class itself represents the table.

By defining database models, you can `interact with the database using Python objects and methods`, rather than writing raw SQL queries. The ORM handles the translation between Python objects and database records, allowing you to work with databases `using object-oriented programming techniques`.

Database models provide a high-level, intuitive way to interact with databases and simplify the process of working with data. They allow you to define the structure of your database tables, specify relationships between tables, and perform `CRUD (Create, Read, Update, Delete)` operations on the data.

Overall, database models are a powerful tool for working with databases in an object-oriented manner, providing a higher level of abstraction and making it easier to manage and manipulate data.

## ðŸ”¹Declarative Base Class

The declarative base class in SQLAlchemy is a class provided by the SQLAlchemy ORM that `simplifies the process of defining database models`. It allows you to define your models using a declarative syntax, where you define the structure of your tables as classes.

Create a file called `models.py` and import it:

```
from sqlalchemy.orm import DeclarativeBase
```

And define it:

```
class Base(DeclarativeBase):
  pass
```

This serves as the declarative base class for all database models you define below.

## ðŸ”¹Defining models:

```
class User(Base):
    __tablename__ = 'users'
    id:Mapped[int] = mapped_column(primary_key=True)
    username:Mapped[str] = mapped_column(nullable=False)
    email_address:Mapped[str]
    comments:Mapped[List["Comment"]] = relationship(back_populates='user')

    def __repr__(self) -> str:
        return f"<User username={self.username}>"


class Comment(Base):
    __tablename__ = 'comments'
    id:Mapped[int] = mapped_column(primary_key=True)
    user_id:Mapped[int] = mapped_column(ForeignKey('users.id'),nullable=False)
    text:Mapped[str] = mapped_column(Text,nullable=False)
    user:Mapped["User"] =relationship(back_populates='comments')

    def __repr__(self):
        return f"<Comment text={self.text} by {self.user.username}>"
```

The User class has attributes such as id, username, email_address, and comments. The comments attribute is defined as a relationship with the Comment model, indicating a `one-to-many` relationship between User and Comment.

The Comment class has attributes such as id, user_id, text, and user. The user attribute is defined as a relationship back to the User model, indicating a `many-to-one` relationship between Comment and User.

The columns are defined using the `Mapped` and `mapped_column` functions.

The comments attribute of the User class is mapped to a relationship with the Comment class. This relationship is defined using the `relationship  function` with the `back_populates parameter` set to 'user'.

This back_populates parameter is used to establish `bidirectional relationships` between two mapped classes. It specifies the attribute on the related class that should be used to navigate from the related class back to the original class.

The `__repr__()` method in both classes overrides the default representation of the objects, providing a custom string representation when printing instances of the classes.

ðŸ‘‰ The **repr**() method is a special method in Python classes that defines how an object should be represented as a string. It is commonly used to provide a human-readable string representation of the object for debugging or informational purposes.

In the use class, the method is defined with the signature `def __repr__(self) -> str` . This indicates that the method takes no arguments ( `self` refers to the instance of the class itself) and returns a string.

The `-> str` annotation after the method signature def **repr**(self) indicates the expected return type of the method. However, in Python, not specifying a return type does not restrict the actual return value of the method. The **repr**() method can still return a string, and it is a common convention for the **repr**() method to return a string representation of an object.

Inside the method, the line `return f"<User username={self.username}>"` constructs a string using an f-string, which is a way to embed expressions inside string literals.

## ðŸ”¹Create Database Tables based on the model definitions.

So after defining our database models we're going to be able to `create objects` and then will use an object oriented approach to save them to our database.

Create `create_tables.py` file:

```
from models import Base
from connect import engine

print(">>>CREATE TABLES>>>>")
Base.metadata.create_all(bind=engine)
```

We define a metadata object and then attach all the database tables created onto that metadata object. Then you bind it to an engine for it to be able to create your database tables in the database.

Before running this file, change the name of the database in the connect file:

```
engine = create_engine('sqlite:///sample2.db', echo=True)
```

Then, run it (remember to activate env) and you see this in the console:

```
>>>CREATE TABLES>>>>
2023-09-29 11:26:35,255 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2023-09-29 11:26:35,255 INFO sqlalchemy.engine.Engine PRAGMA main.table_info("users")
2023-09-29 11:26:35,256 INFO sqlalchemy.engine.Engine [raw sql] ()
2023-09-29 11:26:35,257 INFO sqlalchemy.engine.Engine PRAGMA temp.table_info("users")
2023-09-29 11:26:35,257 INFO sqlalchemy.engine.Engine [raw sql] ()
2023-09-29 11:26:35,258 INFO sqlalchemy.engine.Engine PRAGMA main.table_info("comments")
2023-09-29 11:26:35,258 INFO sqlalchemy.engine.Engine [raw sql] ()
2023-09-29 11:26:35,259 INFO sqlalchemy.engine.Engine PRAGMA temp.table_info("comments")
2023-09-29 11:26:35,260 INFO sqlalchemy.engine.Engine [raw sql] ()
2023-09-29 11:26:35,261 INFO sqlalchemy.engine.Engine
CREATE TABLE users (
        id INTEGER NOT NULL,
        username VARCHAR NOT NULL,
        email_address VARCHAR NOT NULL,
        PRIMARY KEY (id)
)


2023-09-29 11:26:35,262 INFO sqlalchemy.engine.Engine [no key 0.00150s] ()
2023-09-29 11:26:35,268 INFO sqlalchemy.engine.Engine
CREATE TABLE comments (
        id INTEGER NOT NULL,
        user_id INTEGER NOT NULL,
        text TEXT NOT NULL,
        PRIMARY KEY (id),
        FOREIGN KEY(user_id) REFERENCES users (id)
)


2023-09-29 11:26:35,269 INFO sqlalchemy.engine.Engine [no key 0.00139s] ()
2023-09-29 11:26:35,274 INFO sqlalchemy.engine.Engine COMMIT
```

Notice that there are several INFO messages related to querying the SQLite database to gather information about the existing tables. These messages are part of SQLAlchemy's internal process to check the current state of the database.

After that, there are two CREATE TABLE statements, in SQL SYNTAX. Finally, there is an INFO message indicating the end of the transaction: COMMIT. This indicates that the transaction for creating the tables has been committed successfully.

## ðŸ”¹Create and persist objects:

`Persisting objects` refers to the process of saving or storing objects in a persistent storage medium, such as a database or a file system, so that they can be retrieved and used later.

In the context of SQLAlchemy's ORM, persisting objects typically involves creating instances of your defined models (e.g., User or Comment objects) and then adding them to a session. The `session` acts as a transactional boundary and tracks changes made to the objects.

ðŸ‘‰ When using ORM `you don't have to know the details of the SQL that's required` for you to do things such as inserting. All you have to do is to create objects of the model classes that you created and then you use a `session object` to go ahead and persist them to the database.

1. First we create some model objects in our file `persisting.py`:

```
from models import User, Comment

Pelusa = User(
  username='Pelusita',
  email_address = 'pelusa@me.com',
  comments = [
    Comment(
      text = 'This is a comment',
    ),
    Comment(
      text = 'This is another comment',
    )
  ]
)

Dante = User(
  username='Dantete',
  email_address = 'Dante@me.com',
  comments = [
    Comment(
      text = 'This is a meow',
    )
  ]
)

Nemo = User(
  username='Nemito',
  email_address = 'nemo@me.com',
)

```

2. Then we insert them into our database:

- We import the session and connect it to the database:

```
from sqlalchemy.orm import Session
from connect import engine

session = Session(bind=engine)
```

- Then we add our model objects and we commit:

```
session.add_all([Pelusa, Dante, Nemo])
session.commit()


```

- Then we run the code of the file and see the console it is all corrected inserted (you can also see in the DB BROWSER)

```
2023-09-29 12:02:56,911 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2023-09-29 12:02:56,914 INFO sqlalchemy.engine.Engine INSERT INTO users (username, email_address) VALUES (?, ?) RETURNING id
2023-09-29 12:02:56,915 INFO sqlalchemy.engine.Engine [generated in 0.00009s (insertmanyvalues) 1/3 (ordered; batch not supported)] ('Pelusita', 'pelusa@me.com')
2023-09-29 12:02:56,917 INFO sqlalchemy.engine.Engine INSERT INTO users (username, email_address) VALUES (?, ?) RETURNING id
2023-09-29 12:02:56,918 INFO sqlalchemy.engine.Engine [insertmanyvalues 2/3 (ordered; batch not supported)] ('Dantete', 'Dante@me.com')
2023-09-29 12:02:56,918 INFO sqlalchemy.engine.Engine INSERT INTO users (username, email_address) VALUES (?, ?) RETURNING id
2023-09-29 12:02:56,919 INFO sqlalchemy.engine.Engine [insertmanyvalues 3/3 (ordered; batch not supported)] ('Nemito', 'nemo@me.com')
2023-09-29 12:02:56,921 INFO sqlalchemy.engine.Engine INSERT INTO comments (user_id, text) VALUES (?, ?) RETURNING id
2023-09-29 12:02:56,921 INFO sqlalchemy.engine.Engine [generated in 0.00010s (insertmanyvalues) 1/3 (ordered; batch not supported)] (1, 'This is a comment')
2023-09-29 12:02:56,921 INFO sqlalchemy.engine.Engine INSERT INTO comments (user_id, text) VALUES (?, ?) RETURNING id
2023-09-29 12:02:56,922 INFO sqlalchemy.engine.Engine [insertmanyvalues 2/3 (ordered; batch not supported)] (1, 'This
is another comment')
2023-09-29 12:02:56,922 INFO sqlalchemy.engine.Engine INSERT INTO comments (user_id, text) VALUES (?, ?) RETURNING id
2023-09-29 12:02:56,922 INFO sqlalchemy.engine.Engine [insertmanyvalues 3/3 (ordered; batch not supported)] (2, 'This
is a meow')
2023-09-29 12:02:56,923 INFO sqlalchemy.engine.Engine COMMIT

```

## ðŸ”¹Select Statements:

First let's have the session in another file, to avoid repetition of data.

Create `main.py` and just leave this there:

```
from sqlalchemy.orm import Session
from connect import engine


session = Session(bind=engine)

```

In the `persisting.py` file we import from main:

```
from models import User, Comment
from main import session
```

Then, we create the file `selecting_orm.py` and import all we need:

```
from main import session
from models import User
from sqlalchemy import select
```

And create the statement with the session object:

```
users = session.query(User).all()
```

And execute the statement :

```
for user in users:
    print(user)
```

So in the console:

```
2023-09-29 12:55:14,987 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2023-09-29 12:55:14,989 INFO sqlalchemy.engine.Engine SELECT users.id AS users_id, users.username AS users_username, users.email_address AS users_email_address
FROM users
2023-09-29 12:55:14,990 INFO sqlalchemy.engine.Engine [generated in 0.00087s] ()
<User username=Pelusita>
<User username=Dantete>
<User username=Nemito>
```

See more examples of queries in the `selecting_orm.py`.

## ðŸ”¹execute() vs scalars():

The execute() method in SQLAlchemy is used to execute a SQL statement or a constructed SQL expression directly on the database. It returns a `ResultProxy` object, which provides access to the rows and columns returned by the executed statement.

On the other hand, the scalars() method is a convenience method provided by SQLAlchemy that can be used to execute a statement and `retrieve only the first column of the result` set as a scalar value. It is particularly useful when you know the result set will contain only a single column.

## ðŸ”¹Updating Statements:

We also need the session object to update data:

```
comment = session.query(Comment).filter_by(id = 1).first()

comment.text = "This is an updated comment again"

session.commit()
```

This line is the same:

```
comment = session.query(Comment).filter(Comment.id == 1).first()
```

## ðŸ”¹Deleting Statements:

First be sure of what you are going to delete! It's worth to print it first:

```
comment = session.query(Comment).filter(Comment.id == 1).first()
print(comment)

session.delete(comment)
session.commit()
```
